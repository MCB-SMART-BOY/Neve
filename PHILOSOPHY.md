# Neve 设计哲学

## 项目愿景

Neve 是一门为类 Unix 操作系统设计的纯函数式系统配置与包管理语言，目标是完全平替 NixOS 中的 Nix 语言，同时解决 Nix 的历史包袱和设计缺陷。

Neve 将作为自研类 Unix 操作系统的核心组件，承担：
- 系统配置管理
- 包定义与构建
- 环境隔离与复现

---

## 核心设计原则

### 1. 零二义性

**每一个语法构造都必须有且仅有一种解析方式。**

这意味着：
- 解析器可以是简单的 LL(1)，无需回溯
- 代码的含义对人和机器都是确定的
- 不依赖上下文猜测用户意图

实现方式：
- 记录用 `#{ }` 而非 `{ }`，与代码块完全区分
- 闭包用 `fn(x) expr` 而非 `x -> expr`，与类型签名区分
- 列表用 `[ ]`，泛型用 `< >`，绝不混用
- 注释用 `-- --`，不与任何操作符冲突

### 2. 语法统一

**相似的概念使用相似的语法。**

| 概念 | 语法 | 一致性 |
|------|------|--------|
| 命名函数 | `fn name(x) expr` | `fn` 关键字 |
| 匿名函数 | `fn(x) expr` | `fn` 关键字 |
| 函数类型 | `A -> B` | `->` 箭头 |
| match 分支 | `pattern -> expr` | `->` 箭头 |
| 类型声明 | `x: Int` | `:` 冒号 |
| 值绑定 | `x = 1` | `=` 等号 |

### 3. 不依赖缩进

**所有结构都有显式的边界标记。**

- 代码块用 `{ }` 包裹
- 语句用 `;` 终止
- 列表项用 `,` 分隔
- 定义用 `;` 结束

这保证了：
- 代码格式化不影响语义
- 复制粘贴不会破坏程序
- 解析器实现简单可靠

### 4. 纯函数式

**无副作用，无可变状态。**

- 所有函数都是纯函数
- 相同输入永远产生相同输出
- 副作用通过构建描述（derivation）而非直接执行

这带来：
- 完美的可复现性
- 安全的并行构建
- 可靠的缓存机制

### 5. 简洁优先

**在不牺牲清晰性的前提下，追求最少的语法噪音。**

- 17 个关键字，足够表达所有概念
- 记录字段可简写：`#{ name }` 等于 `#{ name = name }`
- 类型推导减少冗余注解
- 管道操作符 `|>` 让数据流清晰

### 6. Unix 哲学

**继承 Unix 的设计智慧。**

- 小而专注：每个模块做好一件事
- 组合优于继承：通过管道和函数组合构建复杂逻辑
- 文本是通用接口：配置、路径、命令都是可处理的数据
- 沉默是金：成功时不输出废话

---

## 与 Nix 的区别

### Nix 的问题

1. **语法二义性**：`{ a = 1; }` 既是记录也可能是函数体
2. **缩进敏感的陷阱**：某些情况下缩进影响解析
3. **隐式行为**：`rec { }` 的递归、`with` 的作用域污染
4. **符号混乱**：`//` 是合并，但看起来像注释
5. **历史包袱**：设计决策难以修改

### Neve 的改进

| Nix 问题 | Neve 方案 |
|----------|-----------|
| `{ }` 多义 | `#{ }` 记录，`{ }` 代码块 |
| `x: x+1` 闭包 | `fn(x) x+1` 明确 |
| `rec { }` 显式递归 | 自动检测，无需标记 |
| `with pkgs;` 隐式导入 | `import pkgs (*)` 显式 |
| `inherit x;` | `#{ x }` 简写 |
| `;` 结尾必须 | `;` 结尾一致 |

---

## 实现原则

### 纯 Rust 实现

整个语言工具链使用纯 Rust 实现，不依赖任何 C/C++ 库：

- **Lexer**：手写或使用 `logos`
- **Parser**：手写递归下降（LL(1) 足够）
- **类型检查**：Hindley-Milner 算法
- **求值器**：Tree-walking 解释器
- **包管理**：Content-addressed store

选择 Rust 的理由：
- 内存安全，无 GC 停顿
- 优秀的错误处理
- 可编译到任何平台
- 适合系统级编程

### 错误信息优先

编译器的错误信息必须：
- 指出确切的出错位置
- 解释为什么这是错误
- 建议如何修复

### 渐进式实现

按优先级分阶段实现：

1. **Phase 1**：核心语言（lexer、parser、类型检查、求值）
2. **Phase 2**：包管理（derivation、store、builder）
3. **Phase 3**：系统配置（模块系统、配置生成）
4. **Phase 4**：工具链（LSP、格式化器、REPL）

---

## 未来计划

### 短期（Phase 1-2）

- [ ] 完成词法分析器
- [ ] 完成语法分析器
- [ ] 实现类型推导
- [ ] 实现解释器
- [ ] 基础标准库
- [ ] Derivation 模型
- [ ] Content-addressed store
- [ ] 沙箱构建器

### 中期（Phase 3）

- [ ] 模块系统完善
- [ ] 系统配置生成
- [ ] Flake 支持
- [ ] 与现有 Nix 生态的兼容层
- [ ] 基础包集合（bootstrap）

### 长期（Phase 4+）

- [ ] Language Server Protocol 支持
- [ ] 代码格式化器
- [ ] 交互式 REPL
- [ ] 增量编译
- [ ] 分布式构建
- [ ] 二进制缓存服务

### 操作系统集成

Neve 最终将成为自研类 Unix 操作系统的核心：

- **系统配置**：声明式定义整个系统状态
- **包管理**：所有软件通过 Neve 构建和管理
- **环境管理**：开发环境、容器、虚拟机配置
- **部署**：从单机到集群的统一管理

---

## 设计决策记录

### 为什么用 `#{ }` 而不是其他符号？

考虑过的方案：
- `@{ }` — `@` 用于模式绑定，有冲突
- `%{ }` — 可行，但 `#` 更常见
- `${ }` — 与插值冲突
- `#{ }` — 无冲突，Ruby 等语言有先例

### 为什么用 `fn(x) expr` 而不是 `\x -> expr`？

- `\` 在终端显示可能有问题
- `fn` 与命名函数一致
- 更容易被新手理解
- 解析更简单（`fn(` 明确开始闭包）

### 为什么用 `-- --` 注释？

- 比 `/* */` 更简洁
- 比单独的 `--` 支持多行
- 不与任何操作符冲突
- 视觉上对称美观

### 为什么默认严格求值？

- 包构建需要确定的执行顺序
- 避免惰性求值的空间泄漏
- 调试更直观
- 用 `lazy` 显式标记需要延迟的地方

---

## 命名由来

**Neve** 在多种语言中意为"雪"（意大利语、葡萄牙语等）。

选择这个名字是因为：
- 简短好记
- 与 Nix（拉丁语"雪"）有精神联系
- 暗示纯净、简洁的设计理念
- 未被其他主流项目占用

---

## 贡献准则

（待项目开源后补充）

---

*最后更新：2025年*
